# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-10-10 18:44+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: YAML Front Matter: original_url
#: original-manual/home.md:1
#, fuzzy, no-wrap
msgid "https://github.com/Marwes/combine/wiki"
msgstr "https://github.com/Marwes/combine/wiki"

#. type: YAML Front Matter: title
#: original-manual/home.md:1
#, fuzzy, no-wrap
msgid "Home"
msgstr "Home"

#. type: Title ##
#: original-manual/home.md:6
#, fuzzy, markdown-text, no-wrap
msgid "What is combine?"
msgstr "combine とは何か"

#. type: Plain text
#: original-manual/home.md:9
#, fuzzy, markdown-text
msgid "`combine` is a parser combinator library. Let's explain that in two steps."
msgstr "`combine` はパーサーコンビネータライブラリです。"

#. type: Plain text
#: original-manual/home.md:11
#, fuzzy, markdown-text, no-wrap
msgid ""
"A \"parser\" is an algorithm that turns a string of input (for example a "
"`&str` or `&[u8]`) into some output (for example `(i32, Vec<i32>)`) "
"according to a grammar.\n"
msgstr ""
"パーサーは入力を分割し(例えば `&str` or `&[u8]`)、何らかの出力(例えば `(i32, "
"Vec<i32>)`)に変換するアルゴリズムです。\n"

#. type: Plain text
#: original-manual/home.md:13
#, fuzzy, markdown-text
msgid ""
"A \"combinator\" refers to the ability to _combine_ multiple smaller parsers "
"into a larger one. In `combine` this is done simply by defining and calling "
"functions which take one or more parsers as arguments and returns a new "
"parser. This is how it looks like:"
msgstr ""
"コンビネーターは、複数の小さなパーサーを組み合わせてより大きなパーサーを作る機能のことです。`combine` では 1 "
"つまたは複数のパーサーを引数として受け取り、新しいパーサーを返す関数を定義して呼び出すことで実現できます。例えば次の通りです。"

#. type: Fenced code block (rust)
#: original-manual/home.md:14
#, fuzzy, no-wrap
msgid ""
"# use combine::parser::range::{range, take_while1};\n"
"# use combine::parser::repeat::{sep_by};\n"
"# use combine::parser::Parser;\n"
"\n"
"let input = \"Hammer, Saw, Drill\";\n"
"\n"
"// a sequence of alphabetic characters\n"
"let tool = take_while1(|c : char| c.is_alphabetic());\n"
"\n"
"// many `tool`s, separated by \", \"\n"
"let mut tools = sep_by(tool, range(\", \"));\n"
"\n"
"let output : Vec<&str> = tools.easy_parse(input).unwrap().0;\n"
"// vec![\"Hammer\", \"Saw\", \"Drill\"]\n"
msgstr ""
"# use combine::parser::range::{range, take_while1};\n"
"# use combine::parser::repeat::{sep_by};\n"
"# use combine::parser::Parser;\n"
"\n"
"let input = \"Hammer, Saw, Drill\";\n"
"\n"
"// a sequence of alphabetic characters\n"
"let tool = take_while1(|c : char| c.is_alphabetic());\n"
"\n"
"// many `tool`s, separated by \", \"\n"
"let mut tools = sep_by(tool, range(\", \"));\n"
"\n"
"let output : Vec<&str> = tools.easy_parse(input).unwrap().0;\n"
"// vec![\"Hammer\", \"Saw\", \"Drill\"]\n"

#. type: Plain text
#: original-manual/home.md:32
#, fuzzy, markdown-text
msgid "_Listing A-1 - 'Hello combine' example_"
msgstr "Listing A-1 - 'Hello combine' example"

#. type: Plain text
#: original-manual/home.md:34
#, fuzzy, markdown-text
msgid ""
"`take_while1`, `range` and `sep_by` are parser combinators from the "
"`combine` library. `tool` and `tools` are parsers produced from those "
"combinators. The latter is also the final parser."
msgstr ""
"`take_while1`、`range`、`sep_by`は`combine`ライブラリのパーサーコンビネータです。`tool`と`tools` "
"はそれらのコンビネータから生成されたパーサーです。tools は作られた最終的なパーサーでもあります。"

#. type: Title ##
#: original-manual/home.md:35
#, fuzzy, markdown-text, no-wrap
msgid "Tutorial"
msgstr "チュートリアル"

#. type: Plain text
#: original-manual/home.md:38
#, fuzzy, markdown-text
msgid "Learn `combine` with the not so quick [Quickstart Tutorial](Tutorial)."
msgstr "詳しくは [Quickstart Tutorial](Tutorial) で学べます。"

#. type: Title ##
#: original-manual/home.md:39
#, fuzzy, markdown-text, no-wrap
msgid "Inner machinery"
msgstr "Inner machinery"

#. type: Plain text
#: original-manual/home.md:42
#, fuzzy, markdown-text
msgid "Every parser in every language needs roughly these four things to work:"
msgstr "様々な言語で実装される様々なパーサーには次の 4 つを必要とします。"

#. type: Plain text
#: original-manual/home.md:47
#, fuzzy, markdown-text
msgid ""
"- [The data to parse or a way to obtain that data](Input-Machinery)  - [A "
"definition of the format to parse](Parser-Trait)  - A way of gathering and "
"returning the information it has found - [A way to notify about Errors "
"during parsing](Error-Handling)"
msgstr ""
"- [解析するデータまたはそのデータの取得方法](Input-Machinery)  - [パースする形式の定義](Parser-Trait)  - "
"見つけた情報を集めて返す方法 - [パース中のエラーを通知する方法](Error-Handling)"

#. type: Plain text
#: original-manual/home.md:49
#, fuzzy, markdown-text
msgid "It may also support one or more of these extra functionalities"
msgstr "また、次の追加機能のサポートも必要とするでしょう。"

#. type: Plain text
#: original-manual/home.md:52
#, fuzzy, markdown-text
msgid ""
"- Resume parsing / streaming of input data - Giving location information of "
"input data tokens (e.g. line, column for text input)"
msgstr "- 入力データのパース／ストリーミングの再開 - 入力データトークンの位置情報の付与（テキスト入力の場合は行や列など）"

#. type: Plain text
#: original-manual/home.md:54
#, fuzzy, markdown-text
msgid ""
"As `combine` attempts to be as flexible as possible in what can be used as "
"input there can be quite a few traits to implement but most of the "
"high-level use should only need to concern itself with a few of them (namely "
"`Stream`, `RangeStream` and `FullRangeStream`, the latter two only for "
"zero-copy parsing)."
msgstr ""
"`compine` "
"は入力として使用できるものに対して可能な限り柔軟であろうとするので、実装すべきトレイトは非常に多くなりますが、アプリケーションレベルで使用する場合は、それらのうちのいくつか "
"(`Stream`、`RangeStream`および`FullRangeStream`, 後者 2 つは zero-copy のパースをする場合のみ) "
"を気にすればよいです。"

#. type: Plain text
#: original-manual/home.md:56
#, fuzzy, markdown-text
msgid ""
"The linked chapters describe the `combine` way of these things and why they "
"are the way they are. This helps a lot understanding error messages and "
"dealing with sticks and stones."
msgstr ""
"リンク先の章ではこれらのことに対する "
"`combine`流を説明し、なぜそのようになるのかを説明します。これは、エラーメッセージの理解に大いに役立ち出会ってもひるまなくなるでしょう。"

#. type: Title ##
#: original-manual/home.md:57
#, fuzzy, markdown-text, no-wrap
msgid "Alternatives"
msgstr "代替になるライブラリ"

#. type: Plain text
#: original-manual/home.md:60
#, fuzzy, markdown-text
msgid "For reference, here are some alternatives in the rust ecosystem:"
msgstr "Rust エコシステムにはこの手のライブラリに他の選択肢があります。"

#. type: Plain text
#: original-manual/home.md:64
#, fuzzy, markdown-text
msgid ""
"- [nom](https://crates.io/crates/nom)  - "
"[pest](https://crates.io/crates/pest)  - "
"[lalrpop](https://crates.io/crates/lalrpop)"
msgstr ""
"- [nom](https://crates.io/crates/nom)  - "
"[pest](https://crates.io/crates/pest)  - "
"[lalrpop](https://crates.io/crates/lalrpop)"

#. type: Plain text
#: original-manual/home.md:65
#, fuzzy, markdown-text
msgid ""
"All parser libraries come with their own trade offs, so choose wisely "
":smile: ."
msgstr "それぞれトレードオフがあります。賢く選定しましょう :smile:"

#. type: YAML Front Matter: original_url
#: original-manual/tutorial.md:1
#, fuzzy, no-wrap
msgid "https://github.com/Marwes/combine/wiki/Tutorial"
msgstr "https://github.com/Marwes/combine/wiki/Tutorial"

#. type: YAML Front Matter: title
#: original-manual/tutorial.md:1
#, fuzzy, no-wrap
msgid "Tutorial "
msgstr "Tutorial"

#. type: Title ##
#: original-manual/tutorial.md:6
#, fuzzy, markdown-text, no-wrap
msgid "Code Structure"
msgstr "コードの構成"

#. type: Plain text
#: original-manual/tutorial.md:9
#, fuzzy, markdown-text
msgid ""
"`combine` is very flexible in regards to its data source and error handling "
"but for the sake of keeping this tutorial simple I will assume that your "
"input is `&str` and that you want extended error information. If you need "
"another input source or want to customize the errors used, see the chapter "
"\"Inner Machinery\" for all the options."
msgstr ""
"`combine` はデータソースとエラーハンドリングの観点でとても柔軟なライブラリですが、このチュートリアルをシンプルなものにするためにインプットを "
"`&str` "
"とし、すでに拡張されたエラーを使うと仮定します。もし他の入力ソースが必要な場合や、使用するエラーをカスタマイズしたい場合は、すべてのオプションについて "
"\"Inner Machinery\" の章を参照してください。"

#. type: Plain text
#: original-manual/tutorial.md:12
#, fuzzy, markdown-text
msgid ""
"Let's start by structuring your parsing code correctly from the beginning.  "
"The 'Hello combine' example works, but only because it only uses the each "
"parser once. To make it re-usable and testable we package it into a "
"function. We also add the `decode()` function to make handle some "
"organizational stuff like transforming the error type."
msgstr ""
"まずは、パースするコードを最初から正しく構成することを始めましょう。'Hello "
"combine'の例はうまくいきますが、それは各パーサーを一度しか使っていないからです。それを再利用やテストができるように関数としてまとめます。また、`decode()` "
"関数を追加してエラータイプの変換などの処理を行うようにします。"

#. type: Plain text
#: original-manual/tutorial.md:14
#, fuzzy, markdown-text
msgid ""
"The code otherwise does the same parsing as 'Hello combine' example in "
"listing A-1 from the first chapter. Errors are returned as String here, in "
"your own code you would likely have your own error type instead. The only "
"real difference is, that I wrapped the input with a "
"[`State`](https://docs.rs/combine/*/combine/stream/state/struct.State.html) "
"which adds line and column information to the parser errors."
msgstr ""
"それ以外のコードは、第 1 章のリスト A-1 にある 'Hello combine' の例と同じパース処理を行います。 ここではエラーを String "
"で返しますが、あなたのコードでは独自のエラータイプを使っているかもしれません。 唯一の違いは入力を "
"[`State`](https://docs.rs/combine/*/combine/stream/state/struct.State.html) "
"でラップして、パーサーエラーに行と列の情報を追加していることです。"

#. type: Fenced code block (rust)
#: original-manual/tutorial.md:15
#, fuzzy, no-wrap
msgid ""
"# use combine::parser::range::{range, take_while1};\n"
"# use combine::parser::repeat::{sep_by};\n"
"# use combine::parser::Parser;\n"
"# use combine::stream::{RangeStream, state::State};\n"
"# use combine::error::ParseError;\n"
"#\n"
"// Copy the fn header as is, only change ------------â®\n"
"//                                                   v\n"
"fn tools<'a, I>() -> impl Parser<I, Output = Vec<&'a str>>\n"
"    where I: RangeStream<Token = char, Range=&'a str>,\n"
"          I::Error: ParseError<I::Token, I::Range, I::Position>,\n"
"{\n"
"    let tool = take_while1(|c : char| c.is_alphabetic());\n"
"    sep_by(tool, range(\", \"))\n"
"}\n"
"\n"
"fn decode(input : &str) -> Result<Vec<&str>, String> {\n"
"    match tools().easy_parse(State::new(input)) {\n"
"        Ok((output, _remaining_input)) => Ok(output),\n"
"        Err(err) => Err(format!(\"{} in `{}`\", err, input)),\n"
"    }\n"
"}\n"
"\n"
"let input = \"Hammer, Saw, Drill\";\n"
"let output = decode(input).unwrap();\n"
msgstr ""
"use combine::parser::range::{range, take_while1};\n"
"use combine::parser::repeat::{sep_by};\n"
"use combine::parser::Parser;\n"
"use combine::stream::{RangeStream, state::State};\n"
"use combine::error::ParseError;\n"
"\n"
"// Copy the fn header as is, only change ------------╮\n"
"//                                                   v\n"
"fn tools<'a, I>() -> impl Parser<I, Output = Vec<&'a str>>\n"
"    where I: RangeStream<Token = char, Range=&'a str>,\n"
"          I::Error: ParseError<I::Token, I::Range, I::Position>,\n"
"{\n"
"    let tool = take_while1(|c : char| c.is_alphabetic());\n"
"    sep_by(tool, range(\", \"))\n"
"}\n"
"\n"
"fn decode(input : &str) -> Result<Vec<&str>, String> {\n"
"    match tools().easy_parse(State::new(input)) {\n"
"        Ok((output, _remaining_input)) => Ok(output),\n"
"        Err(err) => Err(format!(\"{} in `{}`\", err, input)),\n"
"    }\n"
"}\n"
"\n"
"let input = \"Hammer, Saw, Drill\";\n"
"let output = decode(input).unwrap();\n"

#. type: Plain text
#: original-manual/tutorial.md:44
#, fuzzy, markdown-text
msgid "_Listing T-1 - 'Hello combine' example, extended_"
msgstr "Listing T-1 - 'Hello combine' example, extended"

#. type: Plain text
#: original-manual/tutorial.md:46
#, fuzzy, markdown-text, no-wrap
msgid ""
"Any parser that we want to use more than once must be defined in the form "
"`fn xyz() -> impl Parser`, like `tools` in the above example. To use such a "
"parser, you must call the function instead of using it like a variable: "
"`tools()` in listing T-1 vs `tools` in listing A-1.\n"
msgstr ""
"複数回使用したいパーサーは、上の例の `tools` のように `fn xyz() -> impl Parser` "
"という形で定義する必要があります。このようなパーサーを使用するには、変数のように使用するのではなく、関数を呼び出す必要があります。リスト T-1 の "
"`tools()` とリスト A-1 の `tools` を比較してみてください。\n"

#. type: Plain text
#: original-manual/tutorial.md:48
#, fuzzy, markdown-text
msgid ""
"Whenever you create new `fn` parsers, just copy the whole `fn` header from "
"this example, including the `where` clause. Change the function name and "
"adapt the `Output` type. The `I::Error` line is noisy, but unfortunately "
"necessary due to [rust-lang/rust#24159][]. If that is too noisy for you, see "
"chapter TODO."
msgstr ""
"新しい `fn` パーサーを作成するときは、この例から `where` 節を含む `fn` ヘッダーを丸ごとコピーすればよいです。関数名を変更し、 "
"`Output` 型も合わせます。`I::Error` の行はごちゃごちゃしていますが残念ながら [rust-lang/rust#24159][] "
"のために必要です。もしこれがうるさいようであれば TODO の章を参照してください。"

#. type: Plain text
#: original-manual/tutorial.md:50
#, fuzzy, markdown-text
msgid "[rust-lang/rust#24159]: https://github.com/rust-lang/rust/issues/24159"
msgstr "[rust-lang/rust#24159]: https://github.com/rust-lang/rust/issues/24159"

#. type: Title ##
#: original-manual/tutorial.md:51
#, fuzzy, markdown-text, no-wrap
msgid "Parsing"
msgstr "パース"

#. type: Plain text
#: original-manual/tutorial.md:54
#, fuzzy, markdown-text
msgid ""
"Parsing starts at the beginning of the input. The parser then goes forward "
"character by character, deciding what to do next on every step. It can go "
"back a few steps and try something else if it hit a dead end in its "
"logic. It can decide its decoding path on data it has seen previously."
msgstr "パースは入力の先頭から始まります。そして、パーサーは一文字ずつ進めていき、その都度次に何をすべきかを決定していきます。パース中に行き詰まりると、数ステップ戻って別のパースを試みることもできます。また以前に読み取ったデータに基づいて、パースする経路も決められます。"

#. type: Plain text
#: original-manual/tutorial.md:56
#, fuzzy, markdown-text
msgid ""
"Each parser returns some output value which is assembled from the processed "
"characters and/or the output of nested parsers. A parser can alternatively "
"return an error condition if the input did not match its expectations."
msgstr "各パーサーは、以前の処理した字句、またはネストされたパーサーから構成された戻り値を返します。パーサーは予想した値と入力が一致しない場合、代わりにエラー条件を返せます。"

#. type: Plain text
#: original-manual/tutorial.md:58
#, fuzzy, markdown-text
msgid ""
"For all primitive parsers like `digit()` applies: If a parser read and "
"processed some bytes from the input stream, the bytes are consumed and "
"subsequent parsers start where the previous one finished (however there are "
"some special combinators which break this rule)."
msgstr ""
"`digit()`のようなすべてのプリミティブなパーサーに当てはまる話: もしパーサーが入力ストリームからいくつかの byte "
"を読み取り処理した場合、その byte "
"は消費され後続のパーサーは前のパーサーが終了したところから始まります（ただし、このルールを破る特別なコンビネータもいくつかあります）。"

#. type: Title ##
#: original-manual/tutorial.md:59
#, fuzzy, markdown-text, no-wrap
msgid "Understanding the Output type"
msgstr "出力の型を理解する"

#. type: Plain text
#: original-manual/tutorial.md:62
#, fuzzy, markdown-text
msgid ""
"To write parsers effectively, you must understand what happens with the "
"output values."
msgstr "パーサーを効率的に書くためには、値の出力が何かを理解しなければいけません。"

#. type: Plain text
#: original-manual/tutorial.md:64
#, fuzzy, markdown-text
msgid ""
"At the end, there is only a single output type/value. This type/value must "
"contain all the information you want to extract."
msgstr "結論としては、1 つの出力の型/値だけが存在しており、この型/値には抽出したい情報がすべて含まなければいけません。"

#. type: Plain text
#: original-manual/tutorial.md:66
#, fuzzy, markdown-text
msgid ""
"During the parsing process, new outputs arise, some outputs are `map()`ped "
"to different types, some are merged and some are dropped. Fortunately, there "
"is an expressive toolset to manage this."
msgstr ""
"パースの過程では、新しい出力が発生し、ある出力は "
"`map()`され、ある出力はマージされ、ある出力は削除されます。幸いなことにこれを扱うための表現力豊かなツールセットが存在します。"

#. type: Plain text
#: original-manual/tutorial.md:68
#, fuzzy, markdown-text
msgid ""
"Let's first look at a parser that has no nested parsers: "
"`parser::char::digit`. This parser has the output type `char` and consumes "
"one character of the input stream. The output value will be the consumed "
"character. It errors if the consumed character is no digit (0-9)."
msgstr ""
"まずネストがないパーサーとして `parser::char::digit` を見てみましょう。このパーサーは出力タイプに `char` "
"を持ち、入力ストリームを 1 文字消費します。出力値は、消費された文字になります。消費された文字が数字(0-9)でない場合は、エラーになります。"

#. type: Plain text
#: original-manual/tutorial.md:70
#, fuzzy, markdown-text
msgid ""
"The most basic combination of parsers is sequencing and the simplest way "
"this can be done by putting them in a tuples. The output of that tuple "
"parser is also a tuple."
msgstr "パーサーの最も基本的な組み合わせ方法は連続であり、これを最も単純に行う方法はタプルに入れることです。タプルパーサーの出力はタプルです。"

#. type: Fenced code block (rust)
#: original-manual/tutorial.md:71
#, fuzzy, no-wrap
msgid "let two_digits = (digit(), digit()); // Output = (char, char)\n"
msgstr "let two_digits = (digit(), digit()); // Output = (char, char)\n"

#. type: Plain text
#: original-manual/tutorial.md:76
#, fuzzy, markdown-text
msgid ""
"Only chaining parsers using tuples would make the output type very "
"complicated very soon as the output would be an equally large "
"tuple. Fortunately, we have several options to remedy this:"
msgstr "タプルを使ってパーサーを連結するだけでは、出力が同じように大きなタプルになるためすぐに出力型が非常に複雑になります。幸いなことに、これを解決するためのいくつかの選択肢があります。"

#. type: Bullet: '- '
#: original-manual/tutorial.md:84
#, fuzzy, markdown-text
msgid ""
"Drop (unneeded) parts of the output type by mapping or processing it: `let "
"first_digit = (digit(), digit()).map(|(digit1, _digit2)| digit1);` Note: "
"There are often more expressive helpers like [`skip`][] or [`with`][]: `let "
"first_digit = digit().skip(digit());`"
msgstr ""
"出力された型をマッピングまたは加工することで、(不要な)部分を削除。 (例): `let first_digit = (digit(), "
"digit()).map(|(digit1, _digit2)| digit1);` (注意)：[`skip`][] や [`with`][] "
"など、より表現力のあるヘルパーもあります： `let first_digit = digit().skip(digit());`"

#. type: Bullet: '- '
#: original-manual/tutorial.md:84
#, fuzzy, markdown-text
msgid "Collect repeating elements into a `Vec` or similar."
msgstr "繰り返しの要素を `Vec` などにまとめる。"

#. type: Bullet: '- '
#: original-manual/tutorial.md:84
#, fuzzy, markdown-text
msgid ""
"Ignoring a complicated output type and instead taking a `&str` slice of what "
"has been consumed: `let two_digits_str = recognize( (digit(), digit()) );`"
msgstr ""
"複雑な出力型を無視し、代わりに消費された `&str` スライスを取得。`let two_digits_str = recognize( "
"(digit(), digit()) );`"

#. type: Bullet: '- '
#: original-manual/tutorial.md:84
#, fuzzy, markdown-text
msgid "Assemble your (complex/recursive) output type, for example `json::Value`."
msgstr "(複雑な/再帰的な)出力タイプを組み立てる、例えば `json::Value` など。"

#. type: Plain text
#: original-manual/tutorial.md:86
#, fuzzy, markdown-text
msgid "But there is no fits-all strategy, it all depends on your parsing problem."
msgstr "しかし、万能の戦略はなく、全てはあなたがパースしたいものに依存します。"

#. type: Plain text
#: original-manual/tutorial.md:90
#, fuzzy, markdown-text
msgid ""
"[`parser::char::digit`]: "
"https://docs.rs/combine/*/combine/parser/char/fn.digit.html [`with`]: "
"https://docs.rs/combine/*/combine/trait.Parser.html#method.with [`skip`]: "
"https://docs.rs/combine/*/combine/trait.Parser.html#method.skip"
msgstr ""
"[`parser::char::digit`]: "
"https://docs.rs/combine/*/combine/parser/char/fn.digit.html [`with`]: "
"https://docs.rs/combine/*/combine/trait.Parser.html#method.with [`skip`]: "
"https://docs.rs/combine/*/combine/trait.Parser.html#method.skip"

#. type: Title ##
#: original-manual/tutorial.md:91
#, fuzzy, markdown-text, no-wrap
msgid "Understanding your parsing problem"
msgstr "パースしたいものの課題を理解する"

#. type: Plain text
#: original-manual/tutorial.md:94
#, fuzzy, markdown-text
msgid ""
"Research your parsing problem. Make sure you really understand what you want "
"to parse. If, for example you want to parse a JPEG header:"
msgstr ""
"あなたのパースに関する課題を研究しましょう。何をパースしたいのかを本当に理解しているか確認してください。例えば、あなたが JPEG "
"のヘッダーを解析したい場合、"

#. type: Plain text
#: original-manual/tutorial.md:99
#, fuzzy, markdown-text
msgid ""
"- Is there an official specification? - Does the real world follow the "
"specification? (often not 100%)  - Search for other resources like blog "
"posts, they may contain helpful clues.  - Gather examples from different "
"sources, and include them in you tests to catch problems early on."
msgstr ""
"- 公式の仕様は存在していますか？ - 現実の実装はその仕様に則っていますか？(100%ではない場合が多い)  - "
"ブログ記事など、他のリソースを検索してみると、役に立つヒントがあるかもしれません。 - "
"様々な異なる情報源から例を集め、テストに含めることで、問題を早期に発見できます。"

#. type: Title ##
#: original-manual/tutorial.md:100
#, fuzzy, markdown-text, no-wrap
msgid "Sketch your desired output"
msgstr "出力したいものをスケッチする"

#. type: Plain text
#: original-manual/tutorial.md:103
#, fuzzy, markdown-text
msgid ""
"Sketch the type structure that the parser should ideally return. Decide if "
"the parser output needs to be owned (`String`, ...) or if you want to "
"exercise zero-copy so the output references parts of the input (`&str`, "
"...)."
msgstr ""
"パーサーが理想的に返すべき型構造をスケッチしましょう。パーサーが、所有権を持つようなものを出力すべきか (`String`, ...) "
"あるいは、出力が入力の一部を参照するようにゼロコピーを実行したいのか (`&str`, ...) を決めます。"

#. type: Title ##
#: original-manual/tutorial.md:104
#, fuzzy, markdown-text, no-wrap
msgid "Learn by example"
msgstr "例から学ぶ"

#. type: Plain text
#: original-manual/tutorial.md:107
#, fuzzy, markdown-text
msgid ""
"That was a lot of information, but you have not yet any clue on how to write "
"parsers yet? Let's go step by step by showing little examples and explain "
"what common problem they solve."
msgstr "いろいろ情報がありましたが、まだパーサーの書き方について何の手がかりもないのではありませんか？それでは、少しずつ例を挙げながら、どのような問題を解決するのかを説明していきましょう。"

#. type: Plain text
#: original-manual/tutorial.md:109
#, fuzzy, markdown-text
msgid ""
"All parsers and combinators live in the `parser` module, even if some of "
"them are reexported to the main module. In the following chapters, we assume "
"`use combine::parser::*;`"
msgstr ""
"たとえその一部がメインモジュールに再エクスポートされたとしても、すべてのパーサーとコンビネーターは `parser` "
"モジュールにあります。以下の章では、 `use combine::parser::*;` を使うことを前提にします。"

#. type: Plain text
#: original-manual/tutorial.md:111
#, fuzzy, markdown-text
msgid ""
"(Most examples use the [`char`][] module, if you are parsing bytes and not "
"strings there is often an equivalent function in the [`byte`][] module.)"
msgstr ""
"ほとんどの例では [`char`][] モジュールを使用しますが、文字列ではなくバイトをパースする場合は、[`byte`][] "
"モジュールに同等の関数があるのでそれを使用できます。"

#. type: Plain text
#: original-manual/tutorial.md:114
#, fuzzy, markdown-text
msgid ""
"[`char`]: https://docs.rs/combine/*/combine/parser/char/index.html [`byte`]: "
"https://docs.rs/combine/*/combine/parser/byte/index.html"
msgstr ""
"[`char`]: https://docs.rs/combine/*/combine/parser/char/index.html [`byte`]: "
"https://docs.rs/combine/*/combine/parser/byte/index.html"

#. type: Title ###
#: original-manual/tutorial.md:115
#, fuzzy, markdown-text, no-wrap
msgid "Parse constant characters/slices"
msgstr "定型の文字列をパースする"

#. type: Plain text
#: original-manual/tutorial.md:118
#, fuzzy, markdown-text
msgid ""
"Often, a format contains some constant parts. You need to check for their "
"existence, but they don't matter for the parsers output."
msgstr "多くの場合、フォーマットはいくつかの定数部分を含んでいます。それらの存在を確認する必要がありますが、パーサーの出力には関係ありません。"

#. type: Plain text
#: original-manual/tutorial.md:120
#, fuzzy, markdown-text
msgid ""
"Use [`char::char('x')`][char::char] for characters and "
"[`char::string(\"abcde\")`][char::string] (or "
"[`range::range(\"abcde\")`][range::range] if zero-copy) for slices. The "
"output type of these parsers is `char` and `&str` respectively."
msgstr ""
"文字には [`char::char('x')`][char::char] を、スライスには "
"[`char::string(\"abcde\")`][char::string] (0-copy なら "
"[`range::range(\"abcde\")`][range::range]) を用います。これらのパーサーの出力型は、それぞれ `char` と "
"`&str` です。"

#. type: Plain text
#: original-manual/tutorial.md:124
#, fuzzy, markdown-text
msgid ""
"[char::char]: https://docs.rs/combine/*/combine/parser/char/fn.char.html "
"[char::string]: https://docs.rs/combine/*/combine/parser/char/fn.string.html "
"[range::range]: https://docs.rs/combine/*/combine/parser/range/fn.range.html"
msgstr ""
"[char::char]: https://docs.rs/combine/*/combine/parser/char/fn.char.html "
"[char::string]: https://docs.rs/combine/*/combine/parser/char/fn.string.html "
"[range::range]: https://docs.rs/combine/*/combine/parser/range/fn.range.html"

#. type: Title ###
#: original-manual/tutorial.md:125
#, fuzzy, markdown-text, no-wrap
msgid "Parse character classes, for example whitespace"
msgstr "空白文字などの文字クラスをパースします。"

#. type: Plain text
#: original-manual/tutorial.md:128
#, fuzzy, markdown-text
msgid ""
"Human readable formats like JSON ignore whitespace (spaces, tabs, "
"newlines). [`char::space`][] parses all whitespace characters according to "
"the unicode White_Space category. Look into the `parser::char` module for "
"more predefined character classes."
msgstr ""
"JSON のような人間が読める形式では、空白文字（スペース、タブ、改行）は無視されます。[char::space`][] は、ユニコードの "
"White_Space カテゴリに従って、すべてのホワイトスペースをパースします。その他の定義済み文字クラスについては、 `parser::char` "
"モジュールを参照してください。"

#. type: Plain text
#: original-manual/tutorial.md:130
#, fuzzy, markdown-text
msgid ""
"Use [`item::satisfy`][] to define your own character classes. For example "
"`item::satisfy(|c| c != '\\n')` parses everything except a newline. (You may "
"not that this is in the [`item`][] module which means it works regardless of "
"the input type)."
msgstr ""
"独自の文字クラスを定義するには [`item::satisfy`][] を使用します。例えば `item::satisfy(|c| c != "
"'\\n')` は改行以外のすべてをパースします。(これは [`item`][] "
"モジュールの中にあるので、入力のタイプに関係なく動作することを意味します）。"

#. type: Plain text
#: original-manual/tutorial.md:132
#, fuzzy, markdown-text
msgid "The output of each of these parsers is the `char` they have matched."
msgstr "このパーサーの出力は、それぞれがマッチさせた `char` です。"

#. type: Plain text
#: original-manual/tutorial.md:136
#, fuzzy, markdown-text
msgid ""
"[`char::space`]: https://docs.rs/combine/*/combine/parser/char/fn.space.html "
"[`item::satisfy`]: "
"https://docs.rs/combine/*/combine/parser/item/fn.satisfy.html [`item`]: "
"https://docs.rs/combine/*/combine/parser/item/index.html"
msgstr ""
"[`char::space`]: https://docs.rs/combine/*/combine/parser/char/fn.space.html "
"[`item::satisfy`]: "
"https://docs.rs/combine/*/combine/parser/item/fn.satisfy.html [`item`]: "
"https://docs.rs/combine/*/combine/parser/item/index.html"

#. type: Title ###
#: original-manual/tutorial.md:137
#, fuzzy, markdown-text, no-wrap
msgid "Parse consecutive whitespace or words"
msgstr "連続した空白または単語を解析する"

#. type: Plain text
#: original-manual/tutorial.md:140
#, fuzzy, markdown-text
msgid ""
"All the above parsers match just a single letter. Sometimes we want to parse "
"words or consecutive whitespace. This can be done by using the parser "
"combinators from [`repeat`][]."
msgstr ""
"上記のパーサーはすべて 1 文字にのみマッチします。時には、単語や連続した空白を解析したいこともあります。これは [`repeat`][] "
"のパーサコンビネータを使用することで実現できます。"

#. type: Plain text
#: original-manual/tutorial.md:142
#, fuzzy, markdown-text
msgid ""
"If you want to ignore the matched characters, you can use `repeat::skip_*` "
"functions:"
msgstr "マッチした文字を無視したい場合は、 `repeat::skip_*` 関数を使用できます。"

#. type: Plain text
#: original-manual/tutorial.md:148
#, fuzzy, markdown-text
msgid ""
"- `skip_many(space())` - 0 or more whitespace characters (same as "
"`char::spaces()`)  - `skip_many1(space())` - 1 or more whitespace characters "
"- `skip_count(4, space())` - exactly 4 whitespace characters - "
"`skip_count_min_max(1, 4, space())` - 1 to 4 whitespace characters - "
"`skip_until(item::satisfy(|c| c != '\\n'))` - everything until the end of "
"line"
msgstr ""
"- `skip_many(space())` - 0 個以上の空白文字列 (`char::spaces()`と同じ)  - "
"`skip_many1(space())` - 1 個以上の空白文字列 - `skip_count(4, space())` - 4 個の空白文字列 - "
"`skip_count_min_max(1, 4, space())` - 1〜4 個の空白文字列 - "
"`skip_until(item::satisfy(|c| c != '\\n'))` - 行末まで"

#. type: Plain text
#: original-manual/tutorial.md:150
#, fuzzy, markdown-text
msgid ""
"The `skip_*` combinators have the output type `()`, but they nonetheless "
"consume from the input stream."
msgstr "`skip_*` コンビネータは出力型に`()`を持ちますが、それにもかかわらず入力ストリームから消費されます。"

#. type: Plain text
#: original-manual/tutorial.md:152
#, fuzzy, markdown-text
msgid ""
"On the other hand, if you want to have the consumed slice as output, things "
"are more complicated. [`repeat::many`][] works and can easily be used to "
"collect into a `String`, `Vec` or any other type that implements "
"`Extend`. However, for collecting single characters it may not be performant "
"enough."
msgstr ""
"一方、消費されたスライスを出力にしたい場合は、より複雑になります。そのためには[repeat::many`][] はで実現でき、 `String` や "
"`Vec` などの `Extend` を実装している型に簡単に取り込むことができます。しかし、1 "
"文字を収集するためには、十分なパフォーマンスを発揮できないかもしれません。"

#. type: Plain text
#: original-manual/tutorial.md:154
#, fuzzy, markdown-text
msgid ""
"Thus there are some additional alternatives, depending on how you can "
"describe the characters to consume."
msgstr "このように、あなたがどのように文字を消費できるかによっていくつかの選択肢が追加されます。"

#. type: Bullet: '- '
#: original-manual/tutorial.md:158
#, fuzzy, markdown-text
msgid ""
"`range::recognize(repeat::skip_many1(char::letter()))` - Use this if you "
"want to describe the range of interest as a combination of other "
"parsers. Because the output of the inner parsers doesn't matter, you can use "
"the `skip_*` combinators. [`range::recognize`][] will then look at what has "
"been consumed by its inner parser(s) and use that range/slice as its output."
msgstr ""
"`range::recognize(repeat::skip_many1(char::letter()))`. "
"対象の範囲を他のパーサーと組み合わせて記述したい場合に利用します。内部のパーサーの出力は重要ではないので、 `skip_*` "
"コンビネーターが使用できます。[range::recognize`][] "
"は内部のパーサーによって消費されたものを見て、その範囲やスライスを出力として使用します。"

#. type: Bullet: '- '
#: original-manual/tutorial.md:158
#, fuzzy, markdown-text
msgid ""
"`range::take_while1(|c| c.is_alphabetic())` - Here you can inspect "
"characters using a closure. Similar to `skip_until(item::satisfy(..))` (but "
"inverse logic)."
msgstr ""
"`range::take_while1(|c| "
"c.is_alphabetic())`. "
"クロージャを使用して文字を検査することができます。`skip_until(item::satisfy(...))` "
"に似ています（ただし反対のロジックです）。"

#. type: Bullet: '- '
#: original-manual/tutorial.md:158
#, fuzzy, markdown-text
msgid ""
"`range::take_until_range(\">>>\")` - Wait for a constant and return "
"everything that has been consumed before that constant occurred."
msgstr "`range::take_until_range(\">>\")` - 定数値を待ち、その定数値に出会う前に消費されたものを全て返します。"

#. type: Plain text
#: original-manual/tutorial.md:160
#, fuzzy, markdown-text
msgid ""
"(These parsers and more like them all exist in the [`range`][] module which "
"contains parsers specialized to zero-copy input such as `[u8]` and `str`, if "
"you have a different input you may need to make do with [`repeat::many`][]"
msgstr ""
"これらのパーサーや似たようなものは全て [`range`][] モジュールに含まれています。このモジュールには `[u8]` や `str` "
"といったゼロコピー入力に特化したパーサーが含まれており、もし別の入力を想定しているのならば [`repeat::many`][] を使ってください。。"

#. type: Plain text
#: original-manual/tutorial.md:165
#, fuzzy, markdown-text
msgid ""
"[`repeat`]: https://docs.rs/combine/*/combine/parser/repeat/index.html "
"[`repeat::many`]: "
"https://docs.rs/combine/*/combine/parser/repeat/fn.many.html "
"[`range::recognize`]: "
"https://docs.rs/combine/*/combine/parser/range/fn.recognize.html [`range`]: "
"https://docs.rs/combine/*/combine/parser/range/index.html"
msgstr ""
"[`repeat`]: https://docs.rs/combine/*/combine/parser/repeat/index.html "
"[`repeat::many`]: "
"https://docs.rs/combine/*/combine/parser/repeat/fn.many.html "
"[`range::recognize`]: "
"https://docs.rs/combine/*/combine/parser/range/fn.recognize.html [`range`]: "
"https://docs.rs/combine/*/combine/parser/range/index.html"

#. type: Title ###
#: original-manual/tutorial.md:166
#, fuzzy, markdown-text, no-wrap
msgid "Transforming the output"
msgstr "出力の変換"

#. type: Plain text
#: original-manual/tutorial.md:169
#, fuzzy, markdown-text
msgid ""
"At any time, you can manipulate the output value. You can for example drop "
"some parts of it or parse a `&str` made of digits to an `u32`."
msgstr "いつでも出力値を操作できます。例えば、ある部分を削除したり、数字で構成された `&str` を `u32` にパースできます。"

#. type: Plain text
#: original-manual/tutorial.md:171
#, fuzzy, markdown-text
msgid ""
"The relevant functions are part of the [`Parser`][] trait, so you use the "
"`.` notation: `digit().map(|d| d)`."
msgstr "関連する関数は [`Parser`][] trait に含まれているので、 `.` 記法を使用します: `digit().map(|d| d)`."

#. type: Fenced code block (rust)
#: original-manual/tutorial.md:172
#, fuzzy, no-wrap
msgid ""
"    fn map<>(self, f: impl FnMut(O) -> B) -> impl Parser<Output = B> {}\n"
"    fn and_then<>(self, f: impl FnMut(O) -> Result<B, S_ERR>) -> impl "
"Parser<Output = B> {}\n"
"    fn flat_map<>(self, f: impl FnMut(O) -> Result<B, P_ERR>) -> impl "
"Parser<Output = B> {}\n"
msgstr ""
"fn map<>(self, f: impl FnMut(O) -> B) -> impl Parser<Output = B> {}\n"
"fn and_then<>(self, f: impl FnMut(O) -> Result<B, S_ERR>) -> impl "
"Parser<Output = B> {}\n"
"fn flat_map<>(self, f: impl FnMut(O) -> Result<B, P_ERR>) -> impl "
"Parser<Output = B> {}\n"

#. type: Plain text
#: original-manual/tutorial.md:179
#, fuzzy, markdown-text
msgid ""
"The return value of these three functions is a parser again. This is similar "
"to calling `map()` on an `std::iter::Iterator`, which returns an `impl "
"Iterator` again. Like `Iterator`, after combining all the parsers, you have "
"not parsed anything yet, just created an instance of a type that is able to "
"parse your input. Just like iterating starts when calling `next()`, parsing "
"starts when calling `parse*()`."
msgstr ""
"これら 3 つの関数の戻り値は、再びパーサーとなります。これは、 `std::iter::Iterator` に対して `map()` "
"を呼び出すと、再び `impl Iterator` "
"が返されるのと似ています。`Iterator`と同様に、すべてのパーサーを結合した後は、まだ何もパースしておらず入力をパースすることができる型のインスタンスを作成しただけになります。イテレートが`next()`を呼び出したときに始まるように、パースも`parse\\*()` "
"を呼び出したときに開始されます。"

#. type: Plain text
#: original-manual/tutorial.md:181
#, fuzzy, markdown-text
msgid "What is the difference between these functions and when to use them?"
msgstr "これらの機能の違いはなにか、どのような場合に使うのでしょうか。"

#. type: Bullet: '- '
#: original-manual/tutorial.md:194
#, fuzzy, markdown-text
msgid ""
"`map()` allows you to map the output to another type. For example you can "
"convert a `&str` to a `String`, or move some values from tuple form into a "
"custom struct. The closure is not able to return an error."
msgstr ""
"`map()` は、出力を別の型にマップすることができます。例えば、 `&str` を `String` "
"に変換したり、タプル型からカスタム構造体に値を移動させたりすることができます。このクロージャはエラーを返すことができません。"

#. type: Bullet: '  - '
#: original-manual/tutorial.md:194
#, fuzzy, markdown-text
msgid "`(a(), b()).map(|(a, b)| MyType { a: a, b: b} )`"
msgstr "`(a(), b()).map(|(a, b)| MyType { a: a, b: b} )`"

#. type: Bullet: '  - '
#: original-manual/tutorial.md:194
#, fuzzy, markdown-text
msgid "`recognize(skip_many1(letter())).map(|s| s.to_string())`"
msgstr "`recognize(skip_many1(letter())).map(|s| s.to_string())`"

#. type: Bullet: '- '
#: original-manual/tutorial.md:194
#, fuzzy, markdown-text
msgid ""
"`and_then()` is the most capable of the three functions. In contrast to "
"`map()`, the closure returns a `Result<>`. Use this if your transformation "
"may fail, for example if you want to parse some digits into a numeric type."
msgstr ""
"`and_then()`は、3 つの関数の中で最も高機能な関数です。`map()`とは対照的に、クロージャは`Result<>` "
"を返します。例えば、いくつかの数字を数値型にパースする場合など、変換に失敗する可能性がある場合に使用します。"

#. type: Bullet: '  - '
#: original-manual/tutorial.md:194
#, fuzzy, markdown-text
msgid ""
"`recognize(skip_many1(digit())).and_then(|digits : &str| "
"digits.parse::<u32>().map_err(StreamErrorFor::<I>::other) )` (This could "
"also be written with "
"[`from_str(recognize(skip_many1(digit())))`][`from_str`])"
msgstr ""
"`recognize(skip_many1(digit())).and_then(|digits : &str| "
"digits.parse::<u32>().map_err(StreamErrorFor::<I>::other) )` （これは "
"[`from_str(recognize(skip_many1(digit()))`][`from_str`] とも書けます）。"

#. type: Bullet: '  - '
#: original-manual/tutorial.md:194
#, fuzzy, markdown-text
msgid ""
"You can use any constructor of the `error::StreamError` trait to create an "
"error. The most helpful constructors are:"
msgstr "エラーを作成するには、`error::StreamError` トレイトの任意のコンストラクタを使用できます。最も役に立つコンストラクタは次のものです。"

#. type: Bullet: '    - '
#: original-manual/tutorial.md:194
#, fuzzy, markdown-text
msgid "`StreamErrorFor::<I>::other(some_std_error)`"
msgstr "`StreamErrorFor::<I>::other(some_std_error)`"

#. type: Bullet: '    - '
#: original-manual/tutorial.md:194
#, fuzzy, markdown-text
msgid "`StreamErrorFor::<I>::message_message(format!(\"{}\", xyz))`"
msgstr "`StreamErrorFor::<I>::message_message(format!(\"{}\", xyz))`"

#. type: Bullet: '    - '
#: original-manual/tutorial.md:194
#, fuzzy, markdown-text
msgid "`StreamErrorFor::<I>::message_static_message(\"Not supported\")`"
msgstr "`StreamErrorFor::<I>::message_static_message(\"Not supported\")`"

#. type: Bullet: '- '
#: original-manual/tutorial.md:194
#, fuzzy, markdown-text
msgid ""
"`flat_map()` is very similar to `and_then()`, but they differ in the error "
"type the closure must return. Use `flat_map()` if you want to parse some "
"output in more detail with another parser. (see its documentation)"
msgstr ""
"`flat_map()`は`and_then()`に非常に似ていますが、クロージャが返さなければならないエラーの種類が異なります。ある出力を別のパーサーでより詳細に解析したい場合には`flat_map()` "
"を使ってください。(そのドキュメントを参照してください)"

#. type: Bullet: '  - '
#: original-manual/tutorial.md:194
#, fuzzy, markdown-text
msgid ""
"`and_then()` takes an `error::StreamError` where as `flat_map()` takes an "
"`error::ParseError`."
msgstr ""
"`and_then()` は `error::StreamError` を受け取る一方、`flat_map()` は "
"`error::ParseError` を受け取ります。"

#. type: Bullet: '  - '
#: original-manual/tutorial.md:194
#, fuzzy, markdown-text
msgid ""
"`and_then()` will add position information to the error automatically, for "
"`flat_map()` you have to take care of that yourself. You may need to "
"transform the position information."
msgstr ""
"`and_then()`は自動的にエラーに位置情報を追加しますが、`flat_map()` "
"は注意する必要があります。位置情報を追加するような変換が必要かもしれません。"

#. type: Plain text
#: original-manual/tutorial.md:197
#, fuzzy, markdown-text
msgid ""
"[`parser`]: https://docs.rs/combine/*/combine/trait.Parser.html "
"[`from_str`]: https://docs.rs/combine/*/combine/fn.from_str.html"
msgstr ""
"[`parser`]: https://docs.rs/combine/*/combine/trait.Parser.html "
"[`from_str`]: https://docs.rs/combine/*/combine/fn.from_str.html"

#. type: Title ###
#: original-manual/tutorial.md:198
#, fuzzy, markdown-text, no-wrap
msgid "Dynamic parsing"
msgstr "動的なパース"

#. type: Plain text
#: original-manual/tutorial.md:201
#, fuzzy, markdown-text
msgid ""
"You often need to choose a child parser depending on some condition. For "
"example in JSON, you want to parse a list of objects after a `[` and a list "
"of key/object pairs after a `{`. Or you want to parse an escaped string "
"after a `\"` and a number when you encounter a digit. This is most easily "
"done with [`choice::choice`][] which takes a tuple of parsers and tries to "
"parse each of them in turn, returning the output of the first successful "
"one."
msgstr ""
"何らかの条件によって子パーサを選択する必要があることはよくあります。例えば JSON "
"の場合、`[`の後にはオブジェクトのリストを、`{`の後にはキーとオブジェクトのペアのリストをパーズしたいとします。あるいは、エスケープされた文字列を "
"`\"` の後に、数字を見つけたときにその数字をパースしたいとします。これは [`choice::choice`][] "
"を使用することで簡単に行うことができます。"

#. type: Fenced code block (rust)
#: original-manual/tutorial.md:202
#, fuzzy, no-wrap
msgid ""
"choice::choice( (\n"
"    char::char('{').with( parse_key_value_pairs() ),\n"
"    char::char('[').with( parse_list() ),\n"
") )\n"
"// The error will look like this:\n"
"//   Unexpected `<`\n"
"//   Expected `{` or `[`\n"
msgstr ""
"choice::choice( (\n"
"    char::char('{').with( parse_key_value_pairs() ),\n"
"    char::char('[').with( parse_list() ),\n"
") )\n"
"// The error will look like this:\n"
"//   Unexpected `<`\n"
"//   Expected `{` or `[`\n"

#. type: Plain text
#: original-manual/tutorial.md:213
#, fuzzy, markdown-text
msgid ""
"Note that `choice` only attempts the next parser if the previous parser "
"failed to parse the very first token that was fed to it."
msgstr "`choice` は、前のパーサーが最初に送られたトークンのパースに失敗した場合にのみ、次のパーサーを試すことに注意してください。"

#. type: Fenced code block (rust)
#: original-manual/tutorial.md:214
#, fuzzy, no-wrap
msgid ""
"choice::choice( (\n"
"    char::string(\"abc\"),\n"
"    char::string(\"a12\")\n"
") )\n"
"// If we feed this parser with \"a12\" it will not succeed as the first "
"parser only failed after already having found a 'a' successfully\n"
msgstr ""
"choice::choice( (\n"
"    char::string(\"abc\"),\n"
"    char::string(\"a12\")\n"
") )\n"
"// このパーサーに「a12」を与えても、最初のパーサーが「a」をうまく見つけた後に失敗しただけなので、成功しないでしょう。\n"

#. type: Plain text
#: original-manual/tutorial.md:223
#, fuzzy, markdown-text
msgid ""
"To fix this we need to use [`combinator::attempt`][] which makes the wrapped "
"parser act as if it always failed on the first token. (Note that this can be "
"slower and provide worse error messages so avoid using `attempt` unless it "
"is necessary)."
msgstr ""
"これを解決するには、[`combinator::attempt`][]を使用する必要があります。これはラップされたパーサーが、常に最初のトークンで失敗したように動作するようにするものです。これは、ラップしたパーサーを、最初のトークンで失敗したかのように動作させられます "
"(この動作は遅くなり、エラーメッセージも悪くなるので、必要でない限り `attempt` を使わないようにしましょう)。"

#. type: Fenced code block (rust)
#: original-manual/tutorial.md:224
#, fuzzy, no-wrap
msgid ""
"choice::choice( (\n"
"    combinator::attempt(char::string(\"abc\")),\n"
"    combinator::attempt(char::string(\"a12\"))\n"
") )\n"
"// OK: Parsed \"a12\"\n"
msgstr ""
"choice::choice( (\n"
"    combinator::attempt(char::string(\"abc\")),\n"
"    combinator::attempt(char::string(\"a12\"))\n"
") )\n"
"// OK: Parsed \"a12\"\n"

#. type: Plain text
#: original-manual/tutorial.md:233
#, fuzzy, markdown-text
msgid ""
"[`Parser::or`][] works the same as `choice` and can be useful when there are "
"only two alternatives."
msgstr "[`Parser::or`][] は、選択肢が２つのみの場合、choice を使いやすく使えるものです。"

#. type: Plain text
#: original-manual/tutorial.md:237
#, fuzzy, markdown-text
msgid ""
"[`choice::choice`]: "
"https://docs.rs/combine/*/combine/parser/choice/fn.choice.html "
"[`combinator::attempt`]: "
"https://docs.rs/combine/*/combine/parser/combinator/fn.attempt.html "
"[`parser::or`]: "
"https://docs.rs/combine/*/combine/trait.Parser.html#method.or"
msgstr ""
"[`choice::choice`]: "
"https://docs.rs/combine/*/combine/parser/choice/fn.choice.html "
"[`combinator::attempt`]: "
"https://docs.rs/combine/*/combine/parser/combinator/fn.attempt.html "
"[`parser::or`]: "
"https://docs.rs/combine/*/combine/trait.Parser.html#method.or"

#. type: Title ###
#: original-manual/tutorial.md:238
#, fuzzy, markdown-text, no-wrap
msgid "Repeating elements"
msgstr "Repeating elements"

#. type: Plain text
#: original-manual/tutorial.md:241
#, fuzzy, markdown-text
msgid "Often, you have repeating elements, for example a list of numbers."
msgstr "多くの場合、例えば数字のリストなど、繰り返される要素があります。"

#. type: Plain text
#: original-manual/tutorial.md:243
#, fuzzy, markdown-text
msgid ""
"First, you need a parser for a single element of that list: `let hexbyte = ( "
"hexdigit(), hexdigit() );`"
msgstr "まず、そのリストの 1 つの要素に対するパーサーが必要です。`let hexbyte = ( hexdigit(), hexdigit() );`。"

#. type: Plain text
#: original-manual/tutorial.md:245
#, fuzzy, markdown-text
msgid ""
"Then you can use one of the following combinators to collect multiple "
"occurrences of that element:"
msgstr "次に、以下のコンビネーターのいずれかを使用して、その要素の複数の出現を集めます。"

#. type: Plain text
#: original-manual/tutorial.md:254
#, fuzzy, markdown-text
msgid ""
"- `repeat::count(4, hexbyte);` - 0 to 4 hexadecimal bytes - "
"`repeat::count_min_max(1, 4, hexbyte)` - 1 to 4 hexadecimal bytes - "
"`repeat::many(hexbyte)` - 0 or more hexadecimal bytes - "
"`repeat::many1(hexbyte)` - 1 or more hexadecimal bytes - "
"`repeat::sep_by(hexbyte, ',')` - 0 or more hexadecimal bytes, separated by "
"`,` - `repeat::sep_by1(hexbyte, ',')` - 1 or more hexadecimal bytes, "
"separated by `,` - `repeat::sep_end_by(hexbyte, ',')` - 0 or more "
"hexadecimal bytes, all followed by `,` - `repeat::sep_end_by1(hexbyte, ',')` "
"- 1 or more hexadecimal bytes, all followed by `,`"
msgstr ""
"- `repeat::count(4, hexbyte);` - 0 ～ 4 バイトの 16 進数 - "
"`repeat::count_min_max(1, 4, hexbyte)` - 1 ～ 4 バイトの 16 進数 - "
"`repeat::many(hexbyte)` - 0 バイト以上の 16 進数 - `repeat::many1(hexbyte)` - 1 "
"バイト以上の 16 進数 - `repeat::sep_by(hexbyte, ',')` - `,` で区切られた、0 バイト以上の 16 進数 - "
"`repeat::sep_by1(hexbyte, ',')` - `,` で区切られた、1 バイト以上の 16 進数 - "
"`repeat::sep_end_by(hexbyte, ',')` - `,` が付随している、0 バイト以上の 16 進数 - "
"`repeat::sep_end_by1(hexbyte, ',')` - `,` が付随している、1 バイト以上の 16 進数"

#. type: Plain text
#: original-manual/tutorial.md:256
#, fuzzy, markdown-text, no-wrap
msgid ""
"The parser output of each element will be collected into a type that "
"implements `std::iter::Extend<TheNestedParser::Output>` and "
"`std::default::Default`. You can use `Vec`, `HashMap` or `HashSet` for this "
"purpose or even write your own collection. You must always give a type hint, "
"so the combinator knows which collection to use. The best way to do this is "
"to call `.map(|m : Vec<_>| m)` on the collecting combinator.\n"
msgstr ""
"各要素のパーサ出力は `std::iter::Extend<TheNestedParser::Output>` と "
"`std::default::Default` を実装した型に収集されます。繰り返しを扱うために、`Vec`、`HashMap`、`HashSet` "
"を使用でき、または独自のコレクション型を記述することもできます。常に型ヒントを与えて、コンビネータがどのコレクションを使用するかを知らせる必要があります。そのためには収集するコンビネータに対して "
"`.map(|m : Vec<_>| m)` を呼び出すのがもっともよい方法です。\n"

#. type: Plain text
#: original-manual/tutorial.md:258
#, fuzzy, markdown-text
msgid "The following example counts the tools in the inventory list."
msgstr "次の例はインベントリリストにある tool を数える例です。"

#. type: Fenced code block (rust)
#: original-manual/tutorial.md:259
#, fuzzy, no-wrap
msgid ""
"# use std::collections::HashMap;\n"
"# use combine::parser::range::{range, take_while1};\n"
"# use combine::parser::repeat::{sep_by};\n"
"# use combine::parser::Parser;\n"
"#\n"
"#[derive(Default, Debug)]\n"
"struct Tools<'a> (HashMap<&'a str, u32>);\n"
"\n"
"impl<'a> std::iter::Extend<&'a str> for Tools<'a> {\n"
"    fn extend<T : IntoIterator<Item = &'a str>> (&mut self, iter : T) {\n"
"        for tool in iter.into_iter() {\n"
"            let counter = self.0.entry(tool).or_insert(0);\n"
"            *counter += 1;\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"let input = \"Hammer, Saw, Drill, Hammer\";\n"
"\n"
"let tool = take_while1(|c : char| c.is_alphabetic());\n"
"let mut tools = sep_by(tool, range(\", \")).map(|m: Tools| m);\n"
"\n"
"let output = tools.easy_parse(input).unwrap().0;\n"
"// Tools({\"Saw\": 1, \"Hammer\": 2, \"Drill\": 1})\n"
"\n"
msgstr ""
"use std::collections::HashMap;\n"
"use combine::parser::range::{range, take_while1};\n"
"use combine::parser::repeat::{sep_by};\n"
"use combine::parser::Parser;\n"
"\n"
"#[derive(Default, Debug)]\n"
"struct Tools<'a> (HashMap<&'a str, u32>);\n"
"\n"
"impl<'a> std::iter::Extend<&'a str> for Tools<'a> {\n"
"    fn extend<T : IntoIterator<Item = &'a str>> (&mut self, iter : T) {\n"
"        for tool in iter.into_iter() {\n"
"            let counter = self.0.entry(tool).or_insert(0);\n"
"            *counter += 1;\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"let input = \"Hammer, Saw, Drill, Hammer\";\n"
"\n"
"let tool = take_while1(|c : char| c.is_alphabetic());\n"
"let mut tools = sep_by(tool, range(\", \")).map(|m: Tools| m);\n"
"\n"
"let output = tools.easy_parse(input).unwrap().0;\n"
"// Tools({\"Saw\": 1, \"Hammer\": 2, \"Drill\": 1})\n"
"\n"

#. type: Title ###
#: original-manual/tutorial.md:287
#, fuzzy, markdown-text, no-wrap
msgid "Finding the output type"
msgstr "出力の型を見つける"

#. type: Plain text
#: original-manual/tutorial.md:290
#, fuzzy, markdown-text
msgid ""
"The output type of all combinators is stated in the documentation, albeit a "
"little hidden."
msgstr "すべての combinators の出力型は、少し隠れていますがドキュメントに記載されています。"

#. type: Plain text
#: original-manual/tutorial.md:292
#, fuzzy, markdown-text, no-wrap
msgid ""
"First, go to the documentation of the combinator [`repeat::many`][]. Click "
"on the return type, here "
"[`combine::parser::repeat::Many`](https://docs.rs/combine/*/combine/parser/repeat/struct.Many.html). "
"Expand the `impl<..> Parser for X` section. Then you find the exact type "
"next to `type Output`.\n"
msgstr ""
"まず、コンビネーター [`repeat::many`][] のドキュメントにアクセスします。戻り値の型をクリックして、ここでは "
"[`combine::parser::repeat::Many`] "
"(https://docs.rs/combine/*/combine/parser/repeat/struct.Many.html) を選びます "
"`impl<...> Parser for X` セクションを展開します。すると、`type Output`の隣にお目当ての型が見つかります。\n"

#. type: Plain text
#: original-manual/tutorial.md:294
#, fuzzy, markdown-text, no-wrap
msgid ""
"In case of `many`, this type is `F`, meaning that you can choose any type "
"(via a type hint via `.map()`) as long as it implements `Extend<P::Output> + "
"Default`.\n"
msgstr ""
"`many` の場合、この型は `F` です。つまり、 `Extend<P::Output> + Default` を実装していれば、どんな型でも "
"(`.map()` による型ヒントを介して) 選択することができるのです。\n"

#. type: Plain text
#: original-manual/tutorial.md:296
#, fuzzy, markdown-text, no-wrap
msgid ""
"Another example: `range::recognize` has the output `type Output = <P::Input "
"as StreamOnce>::Range`. Your `Range` type is probably `&str` or `&[u8]`, but "
"you can look up your exact range type in the two tables in the [input "
"machinery](Input-Machinery) documentation.\n"
msgstr ""
"他の例: `range::recognize` は `type Output = <P::Input as StreamOnce>::Range` "
"という出力を持っています。`Range`の型はおそらく`&str`か`&[u8]` ですが、正確な型は [input "
"machinery](Input-Machinery) のドキュメントにある 2 つの表で調べることができます。\n"

#. type: Title ###
#: original-manual/tutorial.md:297
#, fuzzy, markdown-text, no-wrap
msgid "Miscellaneous"
msgstr "Miscellaneous"

#. type: Plain text
#: original-manual/tutorial.md:302
#, fuzzy, markdown-text
msgid ""
"- [`parser1.and(parser2)`][] is a shortcut for `(parser1, parser2)` - "
"[`choice::optional`][] can be helpful.  - [`repeat::escaped`][] helps "
"parsing escaped strings."
msgstr ""
"- [`parser1.and(parser2)`][] は `(parser1, parser2)`のショートカットです。 - "
"[`choice::optional`][] は便利です。 - [`repeat::escaped`][] はエスケープ文字のパースに役立ちます。"

#. type: Plain text
#: original-manual/tutorial.md:306
#, fuzzy, markdown-text
msgid ""
"[`parser1.and(parser2)`]: "
":https://docs.rs/combine/*/combine/trait.Parser.html#method.and "
"[`choice::optional`]: "
"https://docs.rs/combine/*/combine/parser/choice/fn.optional.html "
"[`repeat::escaped`]: "
"https://docs.rs/combine/*/combine/parser/repeat/fn.escaped.html"
msgstr ""
"[`parser1.and(parser2)`]: "
":https://docs.rs/combine/*/combine/trait.Parser.html#method.and "
"[`choice::optional`]: "
"https://docs.rs/combine/*/combine/parser/choice/fn.optional.html "
"[`repeat::escaped`]: "
"https://docs.rs/combine/*/combine/parser/repeat/fn.escaped.html"

#. type: Title ##
#: original-manual/tutorial.md:307
#, fuzzy, markdown-text, no-wrap
msgid "Going forward"
msgstr "Going forward"

#. type: Plain text
#: original-manual/tutorial.md:310
#, fuzzy, markdown-text
msgid ""
"I recommend to take some to browse through the parsers and combinators from "
"the `parser` module. This tutorial only mentioned the most important ones, "
"but the more you know the parser toolbox, the better your parsers become."
msgstr ""
"次にすべきこととして、私は`parser` "
"モジュールのパーサーとコンビネーターに目を通しておくことをお勧めします。このチュートリアルでは最も重要なものだけを取り上げましたが、パーサの道具を知れば知るほど、あなたのパーサはより良くなります。"

#. type: Plain text
#: original-manual/tutorial.md:312
#, fuzzy, markdown-text
msgid "Also, take a look at the `examples` folder to see the concepts in action."
msgstr "また、実装の中でこのコンセプトがどう動くかは examples フォルダをご覧ください。"

#. type: Title ##
#: original-manual/tutorial.md:313
#, fuzzy, markdown-text, no-wrap
msgid "Other input types"
msgstr "その他の入力の型"

#. type: Title ###
#: original-manual/tutorial.md:315
#, fuzzy, markdown-text, no-wrap
msgid "Parsing `&[u8]`"
msgstr "`&[u8]` のパース"

#. type: Plain text
#: original-manual/tutorial.md:318
#, fuzzy, markdown-text
msgid ""
"Use the parsers from `parser::byte` instead of the parsers from "
"`parser::char`."
msgstr "`parser::char` の代わりに `parser::byte` を使いましょう。"

#. type: Plain text
#: original-manual/tutorial.md:320
#, fuzzy, markdown-text
msgid "`parser::byte::num` helps parsing binary numbers with the correct endianess."
msgstr "`parser::byte::num` は、正しいエンディアンで 2 進数をパースすることを支援します。"

#. type: Title ###
#: original-manual/tutorial.md:321
#, fuzzy, markdown-text, no-wrap
msgid "Parsing `&[T]`"
msgstr "`&[T]` のパース"

#. type: Plain text
#: original-manual/tutorial.md:324
#, fuzzy, markdown-text
msgid ""
"Use the parsers from `parser::item` instead of the parsers from "
"`parser::char`."
msgstr "`parser::char` の代わりに `parser::byte` を使いましょう。 "

#. type: Title ###
#: original-manual/tutorial.md:325
#, fuzzy, markdown-text, no-wrap
msgid "Parsing from Iterators or `std::io::Read`"
msgstr "イテレータ、もしくは `parser::item` をパースする"

#. type: Plain text
#: original-manual/tutorial.md:328
#, fuzzy, markdown-text
msgid "See the chapter \"Input Machinery\" for more information on the setup."
msgstr "設定の詳細は「機械的な入力」の章をご覧ください。"

#. type: Plain text
#: original-manual/tutorial.md:330
#, fuzzy, markdown-text
msgid ""
"The main difference in relation to the slice based input types is that the "
"input is not `RangeStream`, but only a `Stream`. You need to adapt the "
"`where` clause in all your parsers function definitions."
msgstr ""
"slice ベースの入力タイプとの主な違いは、入力が `RangeStream` ではなく、単なる `Stream` "
"であることです。すべてのパーサーの関数定義で `where` 節を適用する必要があります。"

#. type: Fenced code block (rust)
#: original-manual/tutorial.md:331
#, fuzzy, no-wrap
msgid ""
"# use combine::parser::*;\n"
"# use combine::parser::Parser;\n"
"# use combine::stream::{Stream};\n"
"# use combine::error::ParseError;\n"
"#\n"
"fn tools<'a, I>() -> impl Parser<Input = I, Output = Vec<Vec<u8>>>\n"
"where I: Stream<Item = u8>,\n"
"      I::Error: ParseError<I::Item, I::Range, I::Position>,\n"
"{\n"
"    let tool = repeat::many(byte::letter()).map(|m : Vec<u8>| m);\n"
"    repeat::sep_by(tool, (byte::byte(b','), byte::byte(b' ')))\n"
"}\n"
msgstr ""
"use combine::parser::*;\n"
"use combine::parser::Parser;\n"
"use combine::stream::{Stream};\n"
"use combine::error::ParseError;\n"
"\n"
"fn tools<'a, I>() -> impl Parser<Input = I, Output = Vec<Vec<u8>>>\n"
"where I: Stream<Item = u8>,\n"
"      I::Error: ParseError<I::Item, I::Range, I::Position>,\n"
"{\n"
"    let tool = repeat::many(byte::letter()).map(|m : Vec<u8>| m);\n"
"    repeat::sep_by(tool, (byte::byte(b','), byte::byte(b' ')))\n"
"}\n"

#. type: Plain text
#: original-manual/tutorial.md:346
#, fuzzy, markdown-text
msgid ""
"Without a `RangeStream`, the `range` module is not usable. You can't return "
"slice references to your input either. (This makes `many(letter())` "
"idiomatic again.)"
msgstr ""
"`RangeStream` "
"がなければ、`range`モジュールを使用することはできません。また、入力に対するスライス参照を返すこともできません。(このため "
"`many(letter())` がイディオムになります)。"
